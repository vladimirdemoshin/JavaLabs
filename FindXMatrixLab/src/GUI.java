//импортируем необходимые для работы классы
import java.awt.Color;
import java.util.Random;
import javax.swing.*; 
import javax.swing.text.*;

public class GUI extends JFrame //создаем свой класс, который наследует класс JFrame
{
    //private String filePath = "matrix.txt"; //задает название файла, в котором хранится матрица
    private int[][] matrix; //матрица с 1 и 0
    private final int X_HEIGHT = 5; //константа, которая задаёт высоту буквы 'X', нарисованной из единичек
    private final int X_WIDTH = 5; //константа, которая задаёт ширину буквы 'X', нарисованной из единичек
    
    public GUI() //конструктор класса по умолчанию, инициализирует все компоненты формы
    {
        initComponents();  //унаследованная у класса JFrame функция инициализации
    }

    // содержание функции initComponents(), которое автоматически генерируется
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        showMatrixTextPane = new javax.swing.JTextPane();
        findButton = new javax.swing.JButton();
        infoTextField = new javax.swing.JTextField();
        countXTextField = new javax.swing.JTextField();
        generateButton = new javax.swing.JButton();
        infoTextField1 = new javax.swing.JTextField();
        infoTextField2 = new javax.swing.JTextField();
        mTextField = new javax.swing.JTextField();
        nTextField = new javax.swing.JTextField();
        infoTextField3 = new javax.swing.JTextField();
        errorTextField = new javax.swing.JTextField();
        jMenuBar1 = new javax.swing.JMenuBar();
        openFileMenu = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        jScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        jScrollPane1.setViewportView(showMatrixTextPane);

        findButton.setText("Выделить");
        findButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findButtonActionPerformed(evt);
            }
        });

        infoTextField.setText("Кол-во X: ");
        infoTextField.setEnabled(false);

        countXTextField.setEnabled(false);
        countXTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                countXTextFieldActionPerformed(evt);
            }
        });

        generateButton.setText("Сгенерировать матрицу");
        generateButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateButtonActionPerformed(evt);
            }
        });

        infoTextField1.setText("m: ");
        infoTextField1.setEnabled(false);

        infoTextField2.setText("n: ");
        infoTextField2.setEnabled(false);

        infoTextField3.setText("Введите погрешность:");
        infoTextField3.setEnabled(false);

        openFileMenu.setText("File");
        openFileMenu.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                openFileMenuMouseClicked(evt);
            }
        });
        jMenuBar1.add(openFileMenu);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 938, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(infoTextField1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(infoTextField, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(mTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 131, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(countXTextField, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 131, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(findButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(errorTextField, javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(infoTextField3, javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(generateButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addComponent(infoTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(nTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 131, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(47, 47, 47)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(generateButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(infoTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(mTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(infoTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(nTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addComponent(infoTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(errorTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 341, Short.MAX_VALUE)
                        .addComponent(findButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(infoTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(countXTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(11, 11, 11))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    //обработчик события нажатия кнопки "Сгенерировать матрицу"
    private void generateButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateButtonActionPerformed
       showMatrixTextPane.setText(""); //очищаем текстовое поле с матрицей
       int m = Integer.parseInt(mTextField.getText());  // перевод текстового вида числа в тип int и сохранение в переменную
       int n = Integer.parseInt(nTextField.getText());  // аналогично
       String outputMatrix = generateRandomMatrix(m,n); //генерируем матрицу
       showMatrixTextPane.setText(outputMatrix); //вставляем её в текстовое поле
    }//GEN-LAST:event_generateButtonActionPerformed

    //обработчик события нажатия кнопки "Выделить"
    private void findButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findButtonActionPerformed
        matrix = generateMatrixFromTextPane(); //генерируем числовую матрицу на основе матрицы из текстового поля
        //создаем атрибут для документа ( черный цвет шрифта)
        SimpleAttributeSet black = new SimpleAttributeSet();
        StyleConstants.setForeground(black, Color.BLACK);
        //создаём специальный объект документ, связываем его с текстовым полем для матрицы, что позволит нам задавать свой стиль и цвет для текста 
        StyledDocument doc = showMatrixTextPane.getStyledDocument();
        doc.setCharacterAttributes(0, doc.getLength(), black, false);   //указываем смещение и длину того участка текста, на который хотим наложить стиль    

        //инициализируем размерность матрицы
        int m = matrix.length;
        int n = matrix[0].length;
        
        //создаём отдельную булеву матрицу той же размерности, в которой мы будем отмечать, какие символы нам нужно выделить
        boolean[][] coloredMatrix = new boolean[m][n]; 
        //выделяем память для булевой матрицы и инициализируем по умолчанию false - ничего раскрашивать пока не надо
        for(int i=0;i<m;i++)
        {
            coloredMatrix[i] = new boolean[n];
            for(int j = 0;j<n;j++)
                coloredMatrix[i][j] = false;
        } 
        int countX = 0; //вводим счётчик для количества букв X размером 5x5 в матрице
        int error = Integer.parseInt(errorTextField.getText()); // считываем из поля введённую ошибку
        //проводим два цикла - по каждой строке и каждому столбцу
        //циклы проверяют блоки размером 5x5 на наличие в них буквы X из единичек
        //последовательно проверяются все возможные блоки по ширине матрицы, потом спускаемся на строчку вниз и заново, пока это позволяет размерность матрицы
        for(int i=0;i<m-X_HEIGHT+1;i++) //цикл по строкам
           for(int j=0;j<n-X_WIDTH+1;j++) //цикл по столбцам
           {
               int countOne = 0; //в переменной будет храниться количество единичек на тех местах, где должна быть нарисована X, если их количество будет не меньше чем: максимум - погрешность, то выделяем X
               for(int k = 0; k < X_HEIGHT; k++) //считает количество единичек в текущем блоке
               {
                   if(matrix[i+k][j+k] == 1) countOne++; //считаем количество единичек на диагонали,которая идет с левого верхнего угла в правый нижний ( имеется в виду одна из двух диагоналей, которая образует X)
                   if(matrix[i+X_HEIGHT-1-k][j+k] == 1) countOne++; // считаем количество единичек на второй диагонале
               }
               if((matrix[i+2][j+2] == 1)) countOne--; //если посередине X стоит 1, то мы её посчитали дважды
               if(countOne >= 9 - error) //проверяем, достаточно ли единичек в букве X (в максимальном случае в букве X будет 9 единичек)
               {
                   countX++; //увеличиваем количество иксов
                   for(int k = 0; k < X_HEIGHT; k++)  //если блок подходит под условие, то пометим его и позже выделим красным
                   {
                      coloredMatrix[i+k][j+k] = true;
                      coloredMatrix[i+X_HEIGHT-1 - k][j+k] = true;
                   }
               }
           }
        
       countXTextField.setText(String.valueOf(countX)); //записываем количество иксов
       
       int endlOffset = 0;  //учитываем смещение в документе, которое создается символом переноса строки
       for(int i=0;i<m;i++)
       {
            for(int j=0;j<n;j++)
            {
                if(coloredMatrix[i][j]==true) //если мы пометили, что нужно красить элемент, то красим в красный
                {
                    SimpleAttributeSet red = new SimpleAttributeSet();
                    StyleConstants.setForeground(red, Color.RED);
                    doc = showMatrixTextPane.getStyledDocument();
                    doc.setCharacterAttributes(j+i*n+endlOffset, 1, red, false); //первый параметр определяет смещение в документе текущего символа относительно начала документа
                }
            }
            endlOffset++; //каждый перенос строки добавляет 1 символ к смещению
       }
    }//GEN-LAST:event_findButtonActionPerformed

    private void openFileMenuMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_openFileMenuMouseClicked
        //тут будет открытие файла filechooser'ом
    }//GEN-LAST:event_openFileMenuMouseClicked

    private void countXTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_countXTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_countXTextFieldActionPerformed

    //функция, которая превращает текстовое представление матрицы(из текстового поля) в массив(в текстовом поле должна быть записана матрица из нулей и единиц без пробелов и без лишних переносов строки)
    private int[][] generateMatrixFromTextPane() 
    {
        String stringMatrix = showMatrixTextPane.getText(); //считываем матрицу из текстового поля
        String[] stringMatrixLines = stringMatrix.split("\n"); //разбиваем матрицу по строкам
        int m = stringMatrixLines.length, n = stringMatrixLines[0].length(); // инициализируем размерность матрицы
        int[][] output = new int[m][n]; //создаем массив, в который поместим матрицу
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                output[i][j] = Integer.parseInt(stringMatrixLines[i].charAt(j)+""); //переводим строковое представление 0 и 1 в числовое  
            }
        }
        return output;
    }
    
    private String generateRandomMatrix(int m, int n) //случайным образом генерируется матрица из нулей и единиц размерностью m строк и n столбцов
    {
        Random random = new Random(); //создание объекта генерации случайных чисел
        String outputMatrix = ""; //создаем выходную строку
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
               int number = random.nextInt(3); // генерируем случайное число от 0 до 2
               if(number!=0) number = 1; //повышаем вероятность генерации единички, то есть если сгенерировалось 1 или 2, то выбираем 1, а если сгенерировался 0, то выбираем 0
               outputMatrix += String.valueOf(number); //прибавляем к выходной строке число
           }
           if(i!=m-1) outputMatrix += "\n"; //для последней строки не добавляем перенос строки, для остальных добавляем
        }
        return outputMatrix;
    }
    
    //главная функция, выполняет автоматически сгенерированный код и запускает форму
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField countXTextField;
    private javax.swing.JTextField errorTextField;
    private javax.swing.JButton findButton;
    private javax.swing.JButton generateButton;
    private javax.swing.JTextField infoTextField;
    private javax.swing.JTextField infoTextField1;
    private javax.swing.JTextField infoTextField2;
    private javax.swing.JTextField infoTextField3;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField mTextField;
    private javax.swing.JTextField nTextField;
    private javax.swing.JMenu openFileMenu;
    private javax.swing.JTextPane showMatrixTextPane;
    // End of variables declaration//GEN-END:variables
}
